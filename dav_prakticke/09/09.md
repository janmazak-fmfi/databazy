# Cvičenie 9

#### Relevantná dokumentácia:

* [CREATE TABLE](http://www.postgresql.org/docs/current/static/sql-createtable.html)
* [DROP TABLE](http://www.postgresql.org/docs/current/static/sql-droptable.html)
* [ALTER TABLE](http://www.postgresql.org/docs/current/static/sql-altertable.html)
* [json in PostgreSQL](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-json/)
* [json in SQLite](https://www.sqlite.org/json1.html#:~:text=SQLite%20stores%20JSON%20as%20ordinary,a%20binary%20encoding%20of%20JSON.)
* [constraints](https://www.postgresql.org/docs/current/ddl-constraints.html)
* [kedy vyhodnocovať obmedzenia](https://www.postgresql.org/docs/current/sql-set-constraints.html)
* [PostgreSQL CHECK tutorial](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-check-constraint/)
* [PostgreSQL FOREIGN KEY tutorial](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-foreign-key/)
* [SQLite FOREIGN KEY tutorial](https://www.sqlitetutorial.net/sqlite-foreign-key/) --- pozor, SQLite foreign keys v defaultnom nastavení nevyhodnocuje
* [VIEW](https://www.postgresql.org/docs/current/sql-createview.html)
* [PostgreSQL VIEW tutorial](https://www.postgresqltutorial.com/postgresql-views/)

## Ako vytvoriť model

V prvom rade si dajte pozor na zmätok v pojmoch. Čo je to _atribút_? Toto slovo sa používa (minimálne) v troch rôznych významoch.
* V "matematickom" databázovom relačnom modeli je to "atomický" element, nad ktorým vytvárame relácie (ako množiny atribútov).
* V SQL (čo je praktická implementácia "matematického" relačného modelu) je atribút stĺpcom tabuľky, stĺpce jednotlivých tabuliek sú však nezávislé, dokonca aj keď sa volajú rovnako. Ekvivalenciu medzi SQL a matematickým relačným modelom dosiahneme cez cudzie kľúče, ktoré "stotožnia" stĺpce v rôznych tabuľkách a vytvoria tak "virtuálny" atribút v zmysle matematického relačného modelu. Pomôckou v tomto môže byť rovnaké pomenovanie stĺpcov, napr. môžeme všade hovoriť o emp_id, vrátane tabuľky zamestnancov, kde by stačilo označenie id, ktoré v tejto samotnej tabuľke nevytvorí žiadnu kolíziu.
* V terminológii entitno-relačných modelov _atribút_ znamená vlastnosť entity (a nesúvisí so vzťahmi medzi entitami). Tieto vlastnosti entít naozaj reprezentujeme atribútmi (stĺpcami), ale stĺpcami tiež reprezentujeme vzťahy medzi entitami (napr. pri známke máme stĺpec pre zadávajúceho učiteľa). Na vyjadrenie many-to-many relationship (M:N) dokonca potrebujeme celú novú tabuľku (ktorá tak nezodpovedá žiadnej entite, ale je ľahké ju na entitu rozšíriť, napr. ak do nej pridáme stĺpec s extra informáciou, trebárs čas vzniku riadka).

Pri tvorbe dátového modelu dajte pozor na to, že je možnosť reprezentovať tú istú skutočnosť ako *atribút* entity alebo ako *vzťah* medzi entitami.
Niekedy je lepšie jedno, inokedy druhé. Príklady:
* Ulicu (ako súčasť adresy) reprezentujeme ako samostatnú entitu (t.j. existuje relácia s fixným zoznamom existujúcich ulíc a každá adresa sa musí odkazovať na jednu nich), vs. ulica ako textový atribút bez väzby na čokoľvek iné.
* [Rodinný stav](https://slovak.statistics.sk/PACVPEM/vocabPagesDetails.html?id=35201&lang=sk) ako samostatná entita (tabuľka s "vopred daným" zoznamom stavov) vs. textový atribút (kde si každý vyplní, čo chce, alebo cez CHECK povolíme len obmedzenú množinu hodnôt).

Výhody vytvorenia samostatnej entity:
* Existuje jednoznačný zoznam prípustných hodnôt. Ten možno potom napr. ponúknuť užívateľovi na výber v UI. Taktiež je ľahšie vytvárať z klientskeho programu dotazy, lebo vieme jednoznačne popísať položku, ktorú vyhľadávame.
* Databáza automaticky stráži konzistentnosť, napr. užívateľ nemôže spraviť preklep. Túto konzistentnosť je ľahké preniesť do klientských programov (napr. ak by sme chceli pekné reportovanie chýb) --- na rozdiel od prístupu cez CHECK, kde databáza nevie svoje obmedzenie komunikovať navonok.
* Takýto dátový model je ľahko rozšíriteľný: ak pridáme ďalšiu tabuľku, ktorá sa na inkriminované hodnoty odkazuje, stačí do tejto relácie pridať príslušný cudzí kľúč, nemusíme zdvojovať CHECK a strážiť, že je identický.

Ak teda zadanie hovorí, že pre študenta chceme evidovať meno, nevyplýva z toho ešte, že meno nutne musí byť textové pole pre jednotlivých študentov nezávislé od všetkého ostatného. Môžeme tiež mať konečný zoznam povolených mien a z tabuľky so študentmi sa na nich odkazovať cez cudzí kľúč (či už cez umelé id alebo rovno cez meno). Samozrejme, v tomto prípade hneď vidíme praktické problémy, napr. so zahraničnými študentmi, a teda bolo by to riešenie nevhodné.

Nevýhody vytvorenia samostatnej entity:
* Nehodí sa to v prípade prílišnej variability hodnôt: zväčša nedáva zmysel násilím pchať rôznorodú vec do obmedzenej škatuľky (napr. fixný zoznam prípustných hodnôt pre položku "hobby").
* Potenciálne ťažkosti so zmenami zoznamu povolených hodnôt. Kto bude mať oprávnenie meniť či pridávať hodnoty? Ako sa zmena možných hodnôt distribuuje ostatným, aby nepracovali s neplatným zoznamom?

V niektorých prípadoch sa ukáže ako najvhodnejšie kompromisné riešenie: bežne sa vyskytujúce hodnoty vyriešime cez odkazy na entity, ale ponecháme možnosť pripísať čosi individuálne. Napríklad objednávky v e-shope sú štandardizované, ale tiež majú textové pole pre ad-hoc požiadavky. Pozri tiež úlohu 6 nižšie.

## Tasks

Zadanie predpokladá použitie PostgreSQL. (Ak použijete SQLite, niektoré časti sa možno nebudú dať spraviť.)

Chceme vytvoriť databázu pre evidenciu známok, študentov a učiteľov na strednej škole. Potrebujeme evidovať nasledovné:
* Študent --- meno, priezvisko, trieda, dátum narodenia
* Učiteľ --- meno, priezvisko
* Predmet --- názov predmetu, skratka
* Známka --- samotná známka (text), študent, ktorý učiteľ ju zadal, z akého je predmetu, čas zadania, z čoho bola (napr. že z domácej úlohy), váha známky (do priemeru)
* Nie všetky triedy majú všetky predmety, preto potrebujeme evidovať, ktorá trieda má ktorý predmet.

(V reálnej situácii by sa hodilo evidovať aj niečo ďalšie, ale situácia je zjednodušená, nech nie je práce priveľa.)

---

1. Vytvorte dátový model.
    * Identifikujte relevantné entity, ich atribúty a vzťahy medzi nimi.
    * Pre každý vzťah určte, či ide o typ 1:1, 1:N, M:N.
    * Môžete postupovať pomocou entitno-relačného modelu a vzťahy zakresliť.
    * Pre atribúty zvoľte vhodný dátový typ.

2. Navrhnite štruktúru tabuliek vyššie uvedenej databázy.
    * Vytvorte súbor `znamky.sql`, ktorý bude obsahovať definície tabuliek (`CREATE TABLE`).
    * Na začiatok súboru pridajte príkaz `DROP TABLE IF EXISTS`, aby ste súbor `znamky.sql` mohli spúšťať opakovane.
    * Ak je to vhodné, pomenujte stĺpce tak, aby bolo možné používať prirodzený join.

3. Pridajte základné obmedzenia zabezpečujúce integritu databázy.
    * Pre každú tabuľku zvoľte primárny kľúč. (V niektorých prípadoch dáva zmysel pridať umelý identifikátor, tzv. [_surrogate key_](https://en.wikipedia.org/wiki/Surrogate_key), a jeho hodnoty nechať automaticky generovať databázou, napr. typ [SERIAL](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-serial/) v PostgreSQL.)
    * Zakážte `NULL` v stĺpcoch, kde je nutné evidovať hodnotu (napr. nie je nutné, aby študent mal evidovaný dátum narodenia, ale musí mať meno aj triedu).
    * Obmedzte pomocou `CHECK` možné hodnoty pre dátum narodenia (zvoľte si nejaký zmysluplný rozsah). Vyskúšajte, či vaše obmedzenie funguje pri `INSERT` aj pri `UPDATE`.
    * Pomocou `UNIQUE` zabezpečte, aby trieda mohla mať predmet pridelený len raz (vyhýbame sa duplicitným záznamom).

4. Doplňte potrebné cudzie kľúče.
    * V tabuľke známok hodnoty v stĺpcoch musia odkazovať na existujúceho študenta, učiteľa a predmet.
    * Overte funkčnosť pri `INSERT`, kde odkaz na predmet je neexistujúci alebo `NULL`.
    * Ku všetkým cudzím kľúčom doplňte zmysluplné hodnoty pre `ON DELETE`: pri zmazaní študenta treba zmazať záznamy o jeho známkach; učiteľa alebo predmet nie je možné zmazať, ak sa ich týkajú nejaké záznamy o známkach. Overte, či vaše nastavenia fungujú pri pokuse o zmazanie všetkých učiteľov, všetkých predmetov či jednotlivých študentov.
    * Ku všetkým cudzím kľúčom doplňte zmysluplné hodnoty pre `ON UPDATE` a nastavte okamžité vyhodnocovanie s možnosťou zmeniť ho v rámci transakcie.

5. Preskúmajte mieru normalizácie vášho návrhu.
    * Identifikujte všetky netriviálne funkčné závislosti.
    * Overte, že váš návrh neláme žiadnu z nich. Popíšte prostriedky jazyka SQL, ktorými vynucujete platnosť jednotlivých závislostí.
    * Preverte, že návrh je v 3NF --- ak nie je, dekomponujte relácie, ktoré 3NF nespĺňajú.
    * Premyslite si, či návrh spĺňa BCNF.
    * Môžete využiť online nástroje (napr. tie z literatúry k prednáške).

6. Na evidovanie zriedkavých údajov sa neraz neoplatí pridávať stĺpec. Napr. pri žiakoch máme množstvo príznakov pre poruchy učenia, rodinnú situáciu apod., a mať v tabuľke stovky stĺpcov vyplnených takmer výlučne hodnotami NULL či defaultným FALSE nie je ideálne. Lepším riešením môže byť jediný stĺpec typu json.
    * Pre študentov pridajte atribút typu [`jsonb`](https://www.postgresql.org/docs/15/datatype-json.html) (PostgreSQL).
    Ak používate SQLite, json treba ukladať v textovej podobe, pozrite si dokumentáciu.
    * Zaznamenajte, že niektorí študenti majú dyslexiu.
    * Napíšte dotaz, ktorý zobrazí študentov s dyslexiou.

7. Rozhodli sme sa sprístupniť zadávanie a prezeranie známok cez internet.
    * Pomocou `ALTER TABLE` doplňte do tabuliek študent a učiteľ stĺpce na evidenciu prihlasovacích mien (heslá pre jednoduchosť nepoužijeme, z [bezpečnostných dôvodov](https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/) sa nesmú v databáze ukladať v odkrytej podobe).
    * Pridajte index na vyhľadávanie podľa prihlasovacieho mena tak, aby vyhľadávanie fungovalo case-insensitive.

8. Vypíšte meno študenta, predmet, počet študentových známok z daného predmetu a zoznam týchto známok oddelených čiarkami.
    * Použite funkcie [array_agg](https://www.postgresql.org/docs/current/functions-aggregate.html) a [array_to_string](https://www.postgresql.org/docs/current/functions-array.html).

9. Pre každého učiteľa vypočítajte priemer prirodzeno-číselných známok, ktore zadal:
    * Zohľadnite váhy známok zadané v databáze.
    * Nečíselné známky odfiltrujte pomocou regulárnych výrazov (konštrukcia `WHERE znamka ~ '^[0-9]*$'`).
    * Funkcie pre aritmetiku vyžadujú na vstupe čísla, textové polia treba najprv pretypovať: `CAST(... AS INTEGER)`.

10. Vytvorte pohľad (`VIEW`), ktorý pre každého študenta a predmet, ktorý je priradený jeho triede, zobrazuje priemer jeho známok (alebo NULL, ak žiadne známky nemá). Záznamy by mali byť zoradené podľa mena študenta, potom podľa názvu predmetu, a nakoniec podľa priemeru známok (všetko vzostupne).
    * Overte, že vytvorený pohľad sa zachová aj po odhlásení a opätovnom prihlásení.
    * Overte, že vytvorený pohľad reflektuje zmeny v podkladových dátach.
    * Vytvorte indexy, ktoré pomôžu k rýchlemu výpočtu dotazov využívajúcich vytvorený pohľad.


## Instructions

Altogether, at most 4 points:
* Tasks 1-2, structure of the tables (3NF required): 1 pt.
* Tasks 3-4, foreign keys and other integrity constraints: 1 pt.
* All of the tasks 6-8 together: 1 pt.
* All of the tasks 9-10: 1 pt.

You have an extra week to complete this (so the deadline is 28. 11. 2024).

Send the solutions to `jan.mazak@fmph.uniba.sk` with subject `DAV-C-09`. You may include screenshots/photos of paper writings where useful.
