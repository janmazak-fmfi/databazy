\PassOptionsToPackage{dvipsnames}{xcolor}

\documentclass[12pt]{beamer}
\usetheme{default}
\usecolortheme{crane}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[slovak]{babel}
\usepackage{ucs} % unicode

\usepackage{amsmath}
\usepackage{amsmath, amssymb}
\usepackage{hyperref, url}
\usepackage{graphicx}
\usepackage{array}
\usepackage{alltt}

%\setbeamersize{text margin left=1pt,text margin right=1pt}
\setbeamertemplate{footline}[frame number]
\beamertemplatenavigationsymbolsempty

% https://www.overleaf.com/learn/latex/Using_colours_in_LaTeX
\def\blue#1{\textcolor{Cerulean}{#1}}
\def\green#1{\textcolor{LimeGreen}{#1}}

% database-related stuff
\DeclareMathOperator{\join}{\bowtie}
\DeclareMathOperator{\antijoin}{\rhd}

\DeclareMathOperator{\lubi}{lubi}
\DeclareMathOperator{\capuje}{capuje}
\DeclareMathOperator{\navstivil}{navstivil}
\DeclareMathOperator{\vypil}{vypil}
\DeclareMathOperator{\answer}{answer}


\title{Agregácia v SQL}
\author{Ján Mazák}
\institute{FMFI UK Bratislava}
\date{}


\begin{document}

\frame{\titlepage}



\begin{frame}[fragile]{Agregácia}
Niekedy nás nezaujímajú jednotlivé záznamy relácie, ale jedna agregátna hodnota.
\begin{alltt}
/* počet zamestnancov */

SELECT \alert{COUNT}(e.emp_id)
FROM employee e
\end{alltt}
Agregačné funkcie: COUNT, SUM, AVG, MAX, MIN\dots
\end{frame}

\begin{frame}[fragile]{Agregácia}
Riadky možno rozdeliť do skupín pomocou \alert{GROUP BY}.\\
Na výstupe bude pre každú skupinu 1 riadok.
\begin{alltt}
/* počet zamestnancov v jednotlivých oddeleniach */

SELECT e.dept_id, \alert{COUNT}(e.emp_id) AS c
FROM employee e
\alert{GROUP BY} e.dept_id
\end{alltt}
\end{frame}

\begin{frame}[fragile]{Agregácia}
\blue{HAVING} umožňuje filtrovať skupiny.
(Pomenovanie atribútov vytvorených agregáciou za SELECT sa nedá použiť za \blue{HAVING}.)
{
\small
\begin{alltt}
/* počet zamestnancov v oddeleniach s > 1 zamestnancom */
\end{alltt}
}
\begin{alltt}
SELECT e.dept_id, \alert{COUNT}(e.emp_id) AS c
FROM employee e
\alert{GROUP BY} e.dept_id
\blue{HAVING} COUNT(e.emp_id) > 1
\end{alltt}
\bigskip
\end{frame}

\begin{frame}[fragile]{Agregácia}
Mimo dotazu môžu ísť len agregované hodnoty a atribúty, na ktorých sa všetky záznamy v skupine zhodujú
(toto je z pohľadu databázy zaručené len vtedy, ak sa ten atribút nachádza za GROUP BY).
\begin{alltt}
/* počet zamestnancov v jednotlivých oddeleniach */

SELECT \blue{d.name}, \alert{COUNT}(e.emp_id) AS c
FROM employee e
    JOIN department d ON e.dept_id = d.dept_id
\alert{GROUP BY} d.dept_id, \blue{d.name}
\end{alltt}
(Pridanie \verb|d.name| nemá vplyv na rozdelenie riadkov do skupín.)
\end{frame}

\begin{frame}[fragile]{Agregácia}
Do skupín možno deliť aj podľa viacerých atribútov súčasne (riadky v skupine sa musia zhodovať na všetkých) alebo podľa nejakej vypočítanej hodnoty.
\begin{alltt}
/* počet zamestnancov v skupinách
podľa platu zaokrúhleného na stovky
v jednotlivých oddeleniach */

SELECT d.name, ROUND(e.salary, -2) AS salary,
    \alert{COUNT}(e.emp_id) AS c
FROM employee e
    JOIN department d ON e.dept_id = d.dept_id
\alert{GROUP BY} d.dept_id, d.name, ROUND(e.salary, -2)
\end{alltt}
\end{frame}

\begin{frame}[fragile]{Agregácia}
Postupujte opatrne pri aplikovaní agregačných funkcií na NULL a na potenciálne prázdnu množinu záznamov.
Výsledky neraz nie sú intuitívne, treba podrobne naštudovať dokumentáciu a overiť správanie pre konkrétny DBMS.
Napríklad:
\begin{itemize}
\item \verb|COUNT(stĺpec)| ignoruje NULL, ale \verb|COUNT(*)| ich zaráta (aspoň v MySQL)
\item AVG pre neprázdnu množinu ignoruje NULL a výsledok tak môže byť veľmi nereprezentatívny; pre prázdnu vráti NULL
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Agregácia --- GROUPING SETS}
Možnosť viac GROUP BY v jednom dotaze:
\begin{alltt}
SELECT region, product, SUM(sales)
FROM sales
GROUP BY \alert{GROUPING SETS} (
  (region),          --- Sales by region
  (product),         --- Sales by product
  (region, product), --- Sales by region and product
  ()                 --- Grand total
)
\end{alltt}
Vhodné na rýchlejšie generovanie reportov.\\
Špeciálne prípady CUBE a ROLLUP.
\end{frame}

\begin{frame}[fragile]{WITH --- Common Table Expressions (CTE)}
WITH vytvorí reláciu existujúcu len počas výpočtu dotazu.
\bigskip
\begin{alltt}
\alert{WITH} \blue{pijanPocetAlkoholov}(pijan, c) AS (
    SELECT pijan, COUNT(DISTINCT alkohol)
    FROM lubi
    GROUP BY pijan
)
SELECT MAX(ppa.c)
FROM \blue{pijanPocetAlkoholov} ppa
\end{alltt}
\bigskip
WITH sa často používa pri viackrokovom agregovaní.
V jednom dotaze možno za WITH vymenovať aj viacero relácií oddelených čiarkou.
\end{frame}

\begin{frame}[fragile]{Záznamy, kde sa dosahuje extrém (arg max)}
\begin{alltt}
\alert{WITH} \blue{pijanPocetAlkoholov}(pijan, c) AS (
    SELECT pijan, COUNT(DISTINCT alkohol)
    FROM lubi
    GROUP BY pijan
)
SELECT ppa.pijan
FROM \blue{pijanPocetAlkoholov} ppa
WHERE ppa.c = (
    SELECT MAX(ppa2.c)
    FROM \blue{pijanPocetAlkoholov} ppa2
)
\end{alltt}
\bigskip
\end{frame}

\begin{frame}[fragile]{Agregácia --- chyby}
Pri výpočte \alert{arg max} nemožno použiť ORDER BY a LIMIT, pretože LIMIT vedie k fixnému počtu záznamov vo výsledku
a dopredu nevieme, pre koľko záznamov sa maximum nadobúda.
\\[5mm]

Pomocou ORDER BY a LIMIT 1 možno nájsť samotné maximum,
nie je to však vhodný spôsob:
\begin{itemize}
\item úmysel takého dotazu je skrytý (ORDER BY a LIMIT sa používajú najmä na niečo iné, čiže akoby ste pomocou špecifického LIMIT 1 menili význam ORDER BY)
\item výpočet je neefektívny (treba uložiť celý medzivýsledok, možno aj na disk, ak je veľký; až tak možno aplikovať ORDER BY)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Agregácia --- chyby}
Vnorenie agregovaných funkcií je neprípustné:
\begin{alltt}
SELECT \alert{MAX(COUNT(...))} ...

/* správne: najprv COUNT,
   potom MAX v ďalšom SELECTe */
\end{alltt}
\vspace{10mm}
Agregačnú funkciu nemožno aplikovať priamo na reláciu:
\begin{alltt}
WHERE x = \alert{MAX(r)} ...

/* správne: x = (SELECT MAX(...) FROM r) */
\end{alltt}
\end{frame}

\begin{frame}[fragile]{Agregácia --- chyby}
Dvojitá agregácia sa ťažko číta, neraz nefunguje (kvôli duplicite hodnôt vznikajúcej pri karteziánskom súčine) a je zdrojom chýb:
\begin{alltt}
FROM r, s
...
HAVING COUNT(r.x) = COUNT(s.y)

/* lepšie rozdeliť do osobitných SELECTov
a použiť join alebo jednu z agregácií
vypočítať vopred */
\end{alltt}
\end{frame}


\begin{frame}[fragile]{Vnorené dotazy (inner/nested query, subquery)}
Podľa toho, či výsledok vnoreného dotazu závisí od riadka, pre ktorý sa vyhodnocuje WHERE, rozlišujeme:
\begin{itemize}
\item \alert{nekorelované} --- nezávisí
\item \alert{korelované} --- zavisí
\end{itemize}
Nekorelované dotazy stačí počítať raz, kým korelované musíme počítať pre každý riadok nanovo.
Navyše narúšajú optimalizáciu (prepis dotazu do výpočtovo výhodnejšej podoby),
pretože vo všeobecnosti je ťažké hľadať súvis medzi programom a podprogramom.
Korelované vnorené dotazy sú preto niekedy veľmi pomalé.
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy}
Vnorené dotazy využívajúce IN, NOT IN, ANY, ALL apod. možno prepísať pomocou joinu alebo \alert{antijoinu} (WHERE NOT EXISTS).
Antijoin počíta tie riadky z ľavej tabuľky, ktoré sa nejoinujú so žiadnymi riadkami pravej tabuľky.
\bigskip

Antijoin možno počítať podobne ako join \emph{rýchlo} --- napr. cez triedenie alebo hashovanie.
Pre korelované vnorené dotazy takúto optimalizáciu DBMS zväčša spraviť nevie.
\bigskip

\uv{Najhorší} prípad: vnorený dotaz sa počíta úplne oddelene od vonkajšieho,
napr. pre IN sa najprv zostaví celý zoznam hodnôt, hoci z nich nakoniec potrebujeme len jednu.
V pláne výpočtu reprezentované ako \alert{SubPlan}.
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy}
DBMS sa \alert{nepodarilo} optimalizovať IN cez JOIN.
\medskip

\begin{scriptsize}
\begin{alltt}
/* employees working in the same department as their superior */
SELECT e1.name FROM employee e1
WHERE e1.superior IS NOT NULL AND e1.dept_id IN (
    SELECT e2.dept_id FROM employee e2
    WHERE e2.emp_id = e1.superior
);
\end{alltt}
\end{scriptsize}
\smallskip
\begin{small}
\begin{alltt}
Seq Scan on employee e1
  Filter: ((superior IS NOT NULL) AND (SubPlan 1))
  \alert{SubPlan} 1
    ->  Seq Scan on employee e2
        Filter: (emp_id = e1.superior)


\end{alltt}
\end{small}
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy}
DBMS sa \alert{podarilo} optimalizovať IN cez rýchly JOIN.
\medskip

\begin{scriptsize}
\begin{alltt}
/* employees working in the same department as their superior */
SELECT e1.name FROM employee e1
WHERE e1.superior IS NOT NULL AND e1.dept_id IN (
    SELECT e2.dept_id FROM employee e2
    WHERE e2.emp_id = e1.superior
);
\end{alltt}
\end{scriptsize}
\smallskip
\begin{small}
\begin{alltt}
\alert{Hash Join}
  Hash Cond: (e2.emp_id = e1.superior)
  Join Filter: (e2.dept_id = e1.dept_id)
  ->  Seq Scan on employee e1
        Filter: (superior IS NOT NULL)
  ->  Hash
        ->  Seq Scan on employee e2
\end{alltt}
\end{small}
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy --- NULL v NOT IN}
Dotaz vracia \alert{prázdny} výsledok kvôli NULL v NOT IN.
\medskip

\begin{scriptsize}
\begin{alltt}
/* employees who are not superiors */
SELECT e1.name FROM employee e1
WHERE e1.emp_id NOT IN (
    SELECT e2.superior FROM employee e2
);
\end{alltt}
\end{scriptsize}
\smallskip
Podmienka NOT IN sa vyhodnotí ako
\begin{small}
\begin{alltt}
e1.emp_id <> id1 AND e1.emp_id <> id2 AND ...
  ... AND \alert{e1.emp_id <> NULL}
\end{alltt}
\end{small}
\smallskip
Pretože x <> NULL sa vyhodnotí ako UNKNOWN, celá podmienka
zlyhá a dotaz nevráti žiadne riadky.
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy --- NULL v NOT IN}
Operátor NOT EXISTS \alert{správne spracuje NULL}.
\medskip

\begin{scriptsize}
\begin{alltt}
/* employees who are not superiors (correct version) */
SELECT e1.name FROM employee e1
WHERE NOT EXISTS (
    SELECT 1 FROM employee e2
    WHERE e2.superior = e1.emp_id
);
\end{alltt}
\end{scriptsize}
\smallskip
Ak e2.superior je NULL, podmienka\\
\verb|    e2.superior = e1.emp_id|\\
sa nevyhodnotí ako TRUE, takže dotaz funguje správne.
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy --- NOT EXISTS vs. EXCEPT}
NOT EXISTS vždy možno ekvivalentne prepísať cez \alert{EXCEPT}.
Niekedy je to zrozumiteľnejšie.
\medskip

\begin{scriptsize}
\begin{alltt}
/* version with NOT EXISTS */
SELECT e1.name FROM employee e1
WHERE NOT EXISTS (
    SELECT 1 FROM employee e2
    WHERE e2.superior = e1.emp_id
);

/* equivalent version with EXCEPT */
SELECT e.emp_id, e.name
FROM employee e
\alert{EXCEPT}
SELECT e.emp_id, e.name
FROM employee e
    JOIN employee s ON e.emp_id = s.superior;
\end{alltt}
\end{scriptsize}
\smallskip
(Prečo nerobíme množinový rozdiel len pre mená, ale pridali sme aj id?)
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy}
\begin{scriptsize}
Kombinácia EXCEPT a NOT EXISTS neraz čitateľnejšia ako vnáranie NOT EXISTS.\\
(Rýchlosť závisí od obsahu tabuliek; porovnanie je komplikované.)
\medskip

\begin{alltt}
SELECT d.dept_id FROM department d
    WHERE NOT EXISTS (
      SELECT job FROM employee j
      WHERE NOT EXISTS (
          SELECT 1 FROM employee e
          WHERE e.dept_id = d.dept_id AND e.job = j.job
      )
    );

/* verzia kombinujúca NOT EXISTS a EXCEPT */
---- všetky oddelenia
SELECT dept_id FROM department

EXCEPT

---- oddelenia, ktorým chýba aspoň jedno povolanie
SELECT d.dept_id FROM department d, employee j
WHERE NOT EXISTS (
    SELECT 1 FROM employee e
    WHERE e.dept_id = d.dept_id AND e.job = j.job
);
\end{alltt}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy --- scalar subquery}
\footnotesize
\emph{Zamestnanci zarábajúci viac ako priemer v ich oddelení.}\\[7mm]
\begin{minipage}{.4\pdfpagewidth}
Correlated subquery:
\footnotesize
\begin{alltt}
SELECT e.emp_id, e.salary
FROM employee e
WHERE \blue{e.salary >} (
  SELECT AVG(e2.salary)
  FROM employee e2
  WHERE e2.dept_id =
    e.dept_id
);



\end{alltt}
\end{minipage}
\hfill\vline\hfill
\begin{minipage}{.4\pdfpagewidth}
Join:
\footnotesize
\begin{alltt}
WITH dept_avg AS (
  SELECT dept_id,
    AVG(salary) AS avg_salary
  FROM employee
  GROUP BY dept_id
)
SELECT e.emp_id, e.salary
FROM employee e
  JOIN dept_avg da
    ON e.dept_id = da.dept_id
WHERE \blue{e.salary >} da.avg_salary;
\end{alltt}
\end{minipage}
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy --- NOT IN}
\footnotesize
\emph{Zamestnanci, ktorých nadriadený nie je priamym podriadeným prezidenta.}\\[7mm]
\begin{minipage}{.4\pdfpagewidth}
\alert{Un}correlated subquery:
\footnotesize
\begin{alltt}
SELECT e.emp_id, e.superior
FROM employee e
WHERE \blue{e.superior NOT IN} (
  SELECT \blue{s.emp_id}
  FROM employee s ----superior
  JOIN employee p ----president
    ON s.superior = p.emp_id
  WHERE p.job = 'president'
);

\end{alltt}
\end{minipage}
\hfill\vline\hfill
\begin{minipage}{.4\pdfpagewidth}
Antijoin:
\footnotesize
\begin{alltt}
SELECT e.emp_id, e.superior
FROM employee e
WHERE \blue{NOT EXISTS} (
  SELECT 1
  FROM employee s
  JOIN employee p
    ON s.superior = p.emp_id
  WHERE p.job = 'president'
    \blue{AND s.emp_id = e.superior}
);
\end{alltt}
\end{minipage}
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy --- ALL}
\footnotesize
\emph{Zamestnanci zarábajúci viac ako všetci ich podriadení.}\\[7mm]
\begin{minipage}{.4\pdfpagewidth}
Correlated subquery:
\footnotesize
\begin{alltt}
SELECT e.name
FROM employee e
WHERE e.salary > \blue{ALL} (
  SELECT s.salary
  FROM employee s
  WHERE s.superior = e.emp_id
);

\end{alltt}
\end{minipage}
\hfill\vline\hfill
\begin{minipage}{.4\pdfpagewidth}
Antijoin:
\footnotesize
\begin{alltt}
SELECT e.name
FROM employee e
WHERE NOT EXISTS (
  SELECT 1
  FROM employee s
  WHERE s.superior = e.emp_id
  AND e.salary <= s.salary
);
\end{alltt}
\end{minipage}
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy --- ANY}
\footnotesize
\emph{Zamestnanci zarábajúci menej ako nejaký ich podriadený.}\\[7mm]
\begin{minipage}{.4\pdfpagewidth}
Correlated subquery:
\footnotesize
\begin{alltt}
SELECT e.name
FROM employee e
WHERE e.salary < \blue{ANY} (
  SELECT s.salary
  FROM employee s
  WHERE s.superior = e.emp_id
);
\end{alltt}
\end{minipage}
\hfill\vline\hfill
\begin{minipage}{.4\pdfpagewidth}
Join:
\footnotesize
\begin{alltt}
SELECT DISTINCT e.name
FROM employee e
  JOIN employee sub
    ON sub.superior = e.emp_id
WHERE e.salary < sub.salary;


\end{alltt}
\end{minipage}
\end{frame}

\begin{frame}{Vnorené dotazy --- zhrnutie}
Nevýhody IN, NOT IN, ANY, ALL:
\begin{itemize}
\item Prekážka pre optimalizáciu (ťažko sa hľadá rýchly spôsob výpočtu); čím viac dát, tým väčší problém.
\item Horšie využívanie existujúcich indexov (vytvorenie ad-hoc zoznamu pre IN, ALL atď. preruší prepojenie na existujúce tabuľky).
\item Treba si strážiť prítomnosť NULL.
\end{itemize}
\bigskip

Používajte radšej WHERE NOT EXISTS či EXCEPT
(a pre zložitý vnorený dotaz si skúste pripraviť pomocnú tabuľku so zmysluplným názvom cez WITH ---
to pri optimalizácii vôbec neprekáža, keďže ide len o deklaráciu a DBMS nemá povinnosť ju materializovať).
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy za FROM --- fuj, radšej WITH}
\scriptsize
\begin{alltt}
SELECT outer_query.emp_id, outer_query.name, outer_query.total_salary
FROM (
  SELECT middle_query.emp_id,
    middle_query.salary + COALESCE(middle_query.bonus, 0) AS total_salary
  FROM (
    SELECT e.emp_id, e.name, e.salary,
      (SELECT SUM(b.amount)
       FROM (
         SELECT bonus.emp_id, bonus.amount
         FROM employee_bonus bonus
         WHERE bonus.amount > 1000
       ) AS filtered_bonus
       WHERE filtered_bonus.emp_id = e.emp_id
      ) AS bonus
    FROM (
      SELECT emp_id, name, salary
      FROM employee
      WHERE salary > 50000
    ) AS e
  ) AS middle_query
) AS outer_query
WHERE outer_query.total_salary > 60000;
\end{alltt}
\end{frame}


\begin{frame}{Literatúra}
\begin{itemize}
\item {\scriptsize\url{https://www.postgresqltutorial.com/postgresql-aggregate-functions/}}
\item {\scriptsize\url{https://www.postgresqltutorial.com/} (Sections 4, 5, 7)}
\item {\scriptsize\url{https://learnsql.com/blog/error-with-group-by/}}
\item {\scriptsize\url{https://www.postgresql.org/docs/current/functions-aggregate.html}}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Na zamyslenie}
\begin{itemize}
\item Prejdite si túto prezentáciu pred každým písaním dotazov, najmä ukážky chýb a vhodných postupov.
    Niektorí študenti tieto chyby opakujú celý rok, vrátane písomky, ktorú potom musia písať opakovane.
\item Aký je rozdiel medzi filtrovaním pomocou HAVING a WHERE?
\item Aký je rozdiel medzi \verb|COUNT(x)| a \verb|COUNT(DISTINCT x)|\\
    z hľadiska výsledku a rýchlosti výpočtu?
\item Ako by sme spočítali počet zamestnancov, ktorých mená začínajú jednotlivými písmenami abecedy?
\end{itemize}
\end{frame}


\begin{frame}{Úlohy: SQL}
Databáza: \emph{lubi}(Pijan, Alkohol), \emph{capuje}(Krcma, Alkohol, Cena),
\emph{navstivil}(Id, Pijan, Krcma), \emph{vypil}(Id, Alkohol, Mnozstvo)
\begin{itemize}
	\item počet čapovaných alkoholov
	\item priemerná cena piva
	\item najdrahší čapovaný alkohol (všetky, ak ich je viac)
    \item pijan, ktorý vypil najmenej druhov alkoholu
	\item tržby jednotlivých krčiem
    \item krčma s najväčšou celkovou tržbou
    \item priem. suma prepitá pri 1 návšteve pre jednotlivé krčmy
    \item koľko najviac alkoholov, ktoré nik neľúbi, je v jednej krčme v ponuke?
\end{itemize}
\end{frame}


\end{document}


