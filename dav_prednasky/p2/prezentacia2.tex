\PassOptionsToPackage{dvipsnames}{xcolor}

\documentclass[12pt]{beamer}
\usetheme{default}
\usecolortheme{crane}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[slovak]{babel}
\usepackage{ucs} % unicode

\usepackage{amsmath}
\usepackage{amsmath, amssymb}
\usepackage{hyperref, url}
\usepackage{graphicx}
\usepackage{array}
\usepackage{alltt}

%\setbeamersize{text margin left=1pt,text margin right=1pt}
\setbeamertemplate{footline}[frame number]
\beamertemplatenavigationsymbolsempty

% https://www.overleaf.com/learn/latex/Using_colours_in_LaTeX
\def\blue#1{\textcolor{Cerulean}{#1}}
\def\green#1{\textcolor{LimeGreen}{#1}}

% database-related stuff
\DeclareMathOperator{\join}{\bowtie}
\DeclareMathOperator{\antijoin}{\rhd}

\DeclareMathOperator{\lubi}{lubi}
\DeclareMathOperator{\capuje}{capuje}
\DeclareMathOperator{\navstivil}{navstivil}
\DeclareMathOperator{\vypil}{vypil}
\DeclareMathOperator{\answer}{answer}


\title{Relačný model a SQL}
\author{Ján Mazák}
\institute{FMFI UK Bratislava}
\date{}


\begin{document}

\frame{\titlepage}

\begin{frame}{Relačný model}
Databáza pozostáva z tabuliek (\alert{relácií}).\\[3mm]

Stĺpce --- \alert{atribúty}; každý má doménu (množinu povolených hodnôt, čiže dátový typ prípadne zúžený dodatočnými obmedzeniami). Určené pomenovaním alebo pozíciou.\\[3mm]

Riadky --- \alert{záznamy} (records, rows, tuples, n-tice).
\end{frame}

\begin{frame}[fragile]{Relačný model}
\begin{verbatim}
CREATE TABLE employees (
    id INTEGER PRIMARY KEY,
    lastName TEXT NOT NULL,
    firstName VARCHAR(255),
    age INTEGER CHECK (age >= 18)
);
\end{verbatim}
\end{frame}

\begin{frame}{Relačný model}
Reláciu možno vnímať ako predikát alebo ako (multi)množinu záznamov.\\[3mm]

V bežných DBMS sa relácia chápe ako multimnožina:
\begin{itemize}
\item na poradí riadkov nezáleží;
\item riadky v tabuľke sa môžu opakovať.
\end{itemize}

Odstránenie duplikátnych záznamov z výsledku dotazu:
\begin{alltt}
    SELECT \alert{DISTINCT} x, y FROM ...
\end{alltt}
\end{frame}

\begin{frame}[fragile]{NULL}
\begin{itemize}
\item Špeciálna hodnota \alert{NULL} zodpovedá neznámej hodnote.
\item Trojhodnotová logika, napr. \verb|NULL OR FALSE| je NULL.
\item Test, či je hodnota NULL: \verb|x IS NULL| / \verb|x IS NOT NULL|
\item Pri vytváraní tabuľky možno NULL zakázať.
Inak treba starostlivo zvažovať, ako ovplyvní operátory a agregačné funkcie (napr. priemer hodnôt v stĺpci).
Nehádajte, použite dokumentáciu.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Dotazy v SQL}
Základná štruktúra:
\begin{verbatim}
SELECT attribute1 AS a1, attribute2 AS a2
FROM table AS t
WHERE t.attribute2 > 10
ORDER BY a1, a2
\end{verbatim}
(Všimnite si, že aliasy a1, a2 nemožno použiť nikde vnútri dotazu. Kľúčové slovo AS je takmer všade nepovinné.)
\end{frame}

\begin{frame}[fragile]{Dotazy v SQL}
\begin{itemize}
\item Pri kľúčových slovách jazyka SQL sa nerozlišujú malé a veľké písmená,
ale pre dáta uložené v db áno (ak to nezmeníme napr. použitím ILIKE v podmienke za WHERE).
\item Case-sensitivity názvov tabuliek a atribútov závisí od DBMS a operačného systému.
\item Úvodzovky pre stĺpce: \verb|"atribút s medzerou v názve"|
\item Apostrofy pre konštantné reťazce: \verb|'reťazec'|
\end{itemize}

Bežné konvencie:
\begin{itemize}
\item názvy tabuliek aj atribútov lower case
\item kľúčové slová SQL upper case
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Dotazy v SQL}
Vo výsledku nemusia byť len pôvodné hodnoty atribútov, ale aj čosi z nich vyrátané (napr. aritmetické výrazy zložené z konštánt, funkcií implementovaných v db a hodnôt atribútov daného riadka).\\[3mm]

\begin{verbatim}
SELECT
    concat(e.firstname,' ',e.lastname) AS ename,
    0.8 * e.salary AS salaryAfterTax
    (CASE
        WHEN e.bonus IS NULL THEN e.salary
        ELSE e.bonus + e.salary
    ) AS total_salary,
FROM employee AS e
WHERE dept_id >= 20 AND lower(e.firstname) = 'john'
ORDER BY 0.8 * e.salary
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Zoradenie záznamov}
Zoznam zamestnancov usporiadaný od najvyššieho platu po najnižší, pri rovnakom plate abecedne:
\begin{alltt}
SELECT name, salary, department
FROM employee
\alert{ORDER BY} salary DESC, name ASC
\end{alltt}
\end{frame}

\begin{frame}{Join}
\alert{Join} --- spojenie záznamov z dvoch tabuliek.\\[3mm]

Je to podmnožina karteziánskeho súčinu tabuliek (každý riadok s každým, dvojicu záznamov spojíme do jedného dlhšieho)
špecifikovaná dodatočnými podmienkami na prepájanie.
\end{frame}

\begin{frame}{Join --- karteziánsky súčin}
\includegraphics[scale=.12]{join1}
\end{frame}

\begin{frame}{Join --- INNER JOIN}
\includegraphics[scale=.12]{join2}
\end{frame}

\begin{frame}{Join --- LEFT JOIN}
\includegraphics[scale=.12]{join3}
\end{frame}

\begin{frame}{Join --- RIGHT JOIN}
\includegraphics[scale=.12]{join4}
\end{frame}

\begin{frame}{Join --- FULL OUTER JOIN}
\includegraphics[scale=.12]{join5}
\end{frame}

\begin{frame}[fragile]{Negácia}
Negáciu možno vyjadriť pomocou \alert{NOT EXISTS}:
\begin{alltt}
/* zamestnanci, ktorí nemajú podriadených */
SELECT emp.name FROM employee \blue{emp}
WHERE \alert{NOT EXISTS} (
    SELECT 1 FROM employee \green{emp2}
    WHERE \green{emp2}.superior_id = \blue{emp}.employee_id
)
\end{alltt}
(Nezáleží na tom, ktoré stĺpce sú vymenované za SELECT vo vnútornom dotaze, pretože EXISTS len testuje, či sa tam nachádza aspoň jeden riadok.)
\end{frame}

\begin{frame}[fragile]{Negácia}
Samotný operátor EXISTS bez NOT je ekvivalentný joinu.
\begin{alltt}
/* zamestnanci, ktorí majú podriadených */
SELECT DISTINCT emp.name
FROM employee \blue{emp}
WHERE \alert{EXISTS} (
    SELECT 1 FROM employee \green{emp2}
    WHERE \green{emp2}.superior_id = \blue{emp}.employee_id
)

SELECT DISTINCT emp.name
FROM employee \blue{emp}, employee \green{emp2}
WHERE \green{emp2}.superior_id = \blue{emp}.employee_id
\end{alltt}
\end{frame}

\begin{frame}[fragile]{Všeobecný kvantifikátor}
Jazyk SQL nemá prostriedky na priame vyjadrenie všeobecného kvantifikátora.
Postupovať možno v duchu
$$
    \forall x\ P(x)\qquad \Leftrightarrow\qquad \lnot\ \exists x\ \lnot\, P(x).
$$
Zamestnanci, ktorí majú najvyšší plat spomedzi \alert{všetkých} $\Leftrightarrow$ zamestnanci, ku ktorým \alert{neexistuje} zamestnanec s vyšším platom.
\begin{alltt}
SELECT e.name
FROM employee e
WHERE \blue{NOT EXISTS} (SELECT 1
                  FROM employee e2
                  WHERE e2.salary > e.salary)
\end{alltt}
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy (subqueries)}
Okrem operátora EXISTS sa možno pomocou operátora IN (resp. NOT IN) pýtať na prítomnosť v množine.
\begin{alltt}
SELECT name
FROM employee e
WHERE e.dept_id \alert{IN} (SELECT dept_id
                   FROM department d
                   WHERE d.location = 'New York')
\end{alltt}
IN sa optimalizuje horšie ako join a antijoin (NOT EXISTS), dá sa však v prípade potreby prepísať inak.
IN má tiež nevýhodu, ak sa môže vyskytnúť NULL.
\end{frame}

\begin{frame}[fragile]{Vnorené dotazy (subqueries)}
Ak je výsledkom vnoreného dotazu tabuľka 1x1, možno ju použiť ako skalár.
\begin{alltt}
SELECT name
FROM employee e
WHERE \alert{e.dept_id =} \blue{(SELECT dept_id
                  FROM department d
                  WHERE d.location = 'New York')}
\end{alltt}
Ak by vo vnorenom dotaze vyšlo viac riadkov (alebo žiaden), dôjde k chybe.\\
(Takýmto chybám treba čo najviac predchádzať, napr. použitím UNIQUE už pri vytváraní tabuľky.)
\end{frame}

\begin{frame}{Množinové operácie}
Bez zachovania násobnosti riadkov (matematické množiny):
\begin{itemize}
\item UNION --- zjednotenie
\item INTERSECT --- prienik
\item EXCEPT --- rozdiel množín
\end{itemize}
So zachovaním násobnosti riadkov (multimnožiny):
\begin{itemize}
\item UNION ALL --- zjednotenie
\item INTERSECT ALL --- prienik
\item EXCEPT ALL --- rozdiel množín
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Množinové operácie}
\begin{minipage}{.4\pdfpagewidth}
\begin{alltt}
SELECT nazov
FROM kry

\alert{UNION}

SELECT nazov
FROM stromy
\end{alltt}
\end{minipage}
\begin{minipage}{.4\pdfpagewidth}
\begin{alltt}
SELECT nazov
FROM dreviny

\alert{EXCEPT}

SELECT nazov
FROM stromy
\end{alltt}
\end{minipage}
\end{frame}

\begin{frame}[fragile]{Mačky nežerúce myši --- bežná chyba}
Mačky možno rozdeliť do 4 disjunktných skupín:
\begin{itemize}
\item[A.] nežerie nič
\item[B.] žerie niečo, ale nie myši
\item[C.] žerie myši, ale nič iné
\item[D.] žerie myši aj niečo iné
\end{itemize}
$\hbox{mačky nežerúce myši} = A\cup B$
$\hbox{mačky žerúce iné ako myši} = B\cup D$
\\[3mm]

Ak je dotaz o \uv{mačkách nežerúcich myši} a máme za WHERE \uv{$\hbox{potrava} <> \hbox{myši}$}, asi je to nesprávne.
Pre určenie toho, či mačka žerie myši, je úplne irelevantná existencia záznamov o tom, že žerie niečo iné ako myši.

(Dve množiny popísané vyššie však budú totožné, ak každá mačka žerie práve jednu potravu.)
\end{frame}

\begin{frame}[fragile]{CREATE TEMPORARY TABLE}
Používateľ si vie sám vytvoriť dočasnú tabuľku, ktorá zanikne po odpojení od db alebo na konci transakcie.
(Taká tabuľka nemusí fyzicky existovať, DBMS ju môže pri každom použití nanovo vypočítať.)
\begin{alltt}
\alert{CREATE TEMPORARY TABLE} \blue{employee_details} AS (
    SELECT e.emp_id, e.name, e.dept_id,
           d.name, d.location
    FROM employee e, department d
    WHERE e.dept_id = d.dept_id
);
SELECT * FROM \blue{employee_details} WHERE ...;
\end{alltt}
Hodí sa to napr. ak chceme opakovane využívať ten istý komplikovaný join.
\end{frame}


\begin{frame}[fragile]{VIEW}
Prístup k dátam možno uľahčiť vytvorením pohľadu (VIEW).
\begin{alltt}
\alert{CREATE VIEW} \blue{employee_details} AS (
    SELECT e.emp_id, e.name, e.dept_id,
           d.name, d.location
    FROM employee e, department d
    WHERE e.dept_id = d.dept_id
);

SELECT * FROM \blue{employee_details} WHERE ...;
\end{alltt}
VIEW je permanentný objekt v db. Jeho riadky však nemusia byť materializované.
Možno cezeň aj vkladať dáta, ale nerobte to (veľa komplikácií s NULL).
\end{frame}


\begin{frame}[fragile]{Funkcie pre jednotlivé dátové typy}
Pri praktickej práci v SQL využívame rôzne funkcie pre špecifické dátové typy.
\begin{itemize}
\item dátum a čas
\item reťazce
\item numerické výpočty
\item pretypovanie
\item \dots
\item často špecifické pre konkrétny DBMS
\item nebudeme s nimi strácať čas, ľahko sa rieši za pochodu (dokumentácia / LLM)
\end{itemize}
\end{frame}


\begin{frame}[fragile]{How to write SQL}
Zapisujte dotazy čitateľne a zrozumiteľne.\\
Vyhýbajte sa zápisom vedúcim k neefektívnemu výpočtu.\\[3mm]
\begin{itemize}
\item {\scriptsize\url{https://github.com/jarulraj/sqlcheck/blob/master/README.md#query-anti-patterns}}
\item {\scriptsize\url{https://www.stratascratch.com/blog/best-practices-to-write-sql-queries-how-to-structure-your-code/}}
\item {\scriptsize\url{https://www.sqlstyle.guide/}}
\end{itemize}
\vspace*{3mm}
Prečítajte si tieto konvencie \emph{teraz} a nezaťažujte budúcich kolegov nevhodnými zápismi.
(Berte ich však ako odporúčania; rôzne zdroje v niektorých veciach nesúhlasia. Zvyčajne sa pri existujúcom kóde riadime miestnymi konvenciami.)
\end{frame}


\begin{frame}{Literatúra}
\begin{itemize}
\item {\scriptsize\url{https://cs186berkeley.net/notes/note1/}}
\item {\scriptsize\url{https://cs186berkeley.net/notes/note2/}}
\item {\scriptsize\url{https://www.postgresqltutorial.com/} (Sections 1, 2, 3)}
\item {\scriptsize\url{https://www.w3schools.com/sql/sql_intro.asp}}
\item {\scriptsize\url{https://sqlbolt.com/lesson/select_queries_introduction}}
\item {\scriptsize\url{https://www.learnsqlonline.org/}}
\item {\scriptsize\url{https://www.postgresqltutorial.com/postgresql-views/managing-postgresql-views/}}
\item {\scriptsize\url{https://drive.google.com/file/d/1HCq2KMZ05UvtXGe1nTqNmkwhc3X-NLI3/view}}
\end{itemize}
\end{frame}


\begin{frame}{Na zamyslenie}
\begin{itemize}
\item Akú časovú zložitosť má výpočet DISTINCT (v závislosti od počtu riadkov za predpokladu, že sa všetky riadky zmestia do RAM)?
\item Join tabuliek sa dá počítať len z dvoch tabuliek naraz. Ak ich máme viac, join rátame postupne
    (predstavte si operátorový strom pre binárnu operáciu, v listoch sú pôvodné tabuľky a v koreni výsledok joinu).
    Koľko je možných postupov na výpočet joinu $4$ tabuliek? Odhadnite počet postupov pre $n$ tabuliek.
\item Vymyslite postup výpočtu INTERSECT. Akú má časovú zložitosť v závislosti od počtu riadkov relácií na vstupe? (Chcete lepšiu ako kvadratickú zložitosť.)
\end{itemize}
\end{frame}


\begin{frame}{Úlohy: SQL}
Databáza: \emph{osoba}(meno), \emph{pozna}(kto, koho)
\begin{itemize}
    \item osoby, ktoré poznajú sysľa
    \item osoby, ktoré poznajú aspoň dve entity\\ (nemusia to byť osoby)
    \item osoby, ktoré nepoznajú nič a nikoho
    \item osoby, ktoré nepoznajú žiadne iné osoby
    \item osoby, ktoré poznajú iba Jožka
    \item osoby, ktoré pozná presne jedna osoba
    \item osoby, ktoré poznajú všetkých známych svojich známych
%    \item osoby, ktoré majú všetky vzťahy symetrické
\end{itemize}
\end{frame}


\end{document}


